

char **get_command_args(t_token **token)
{
    char **args;
    t_token *temp;
    int i;

    i = 0;
    temp = *token;
    while (temp && temp->token_type == TK_WORD)
    {
        i++;
        temp = temp->next;
    }
    args = ft_calloc(i + 1, sizeof(char *));
    if (!args)
        return (NULL);
    temp = *token;
    i = 0;
    while (temp && temp->token_type == TK_WORD)
    {
        args[i] = ft_strdup(temp->value);
        if (!args[i])
            return (destroy_str_arr(args), NULL);
        i++;
        temp = temp->next;
    }
    return (args[i] = NULL, (*token)->next = temp, args);
}

void add_redir_node(t_astnode **node, t_astnode *new_node)
{
    t_astnode *iter;

    if (!(*node))
    {
        (*node) = new_node;
        new_node->parent = NULL;
    }
    else
    {
        iter = *node;
        while (iter && iter->right)
            iter = iter->right;
        new_node->parent = iter;
        iter->right = new_node;
    }
}

void set_redir_type(t_astnode *new_node, t_token_type type)
{
    if (type == TK_LAPPEND || type == TK_RAPPEND)
        new_node->data.redirection.mode = O_APPEND;
    else
        new_node->data.redirection.mode = 0;
    if (type == TK_LREDIR || type == TK_LAPPEND)
        new_node->type = TK_LREDIR;
    else
        new_node->type = TK_RREDIR;
}

void remove_token(t_token **token_list)
{
    t_token *iter;

    iter = *token_list;
    if (!iter->next && !iter->prev)
        *token_list = NULL;
    else if (!iter->prev)
    {
        *token_list = iter->next;
        (*token_list)->prev = iter->prev;
    }
    else if (!iter->next)
    {
        iter->prev->next = NULL;
        (*token_list) = NULL;
    }
    else
    {
        iter->prev->next = iter->next;
        iter->next->prev = iter->prev;
        (*token_list) = iter->next;
    }
    free(iter->value);
    free(iter);
    iter = NULL;
}

int parse(t_token **tokens_iter, t_astnode **node, t_node **envl)
{
    int ret;

    ret = 0;
    if ((*tokens_iter)->token_type == TK_WORD)
        ret = parse_word(tokens_iter, node);
    else if ((*tokens_iter)->token_type == TK_PIPE)
        ret = parse_pipe(tokens_iter, node);
    else if ((*tokens_iter)->token_type == TK_LREDIR || (*tokens_iter)->token_type == TK_LAPPEND)
        ret = parse_redir(tokens_iter, node);
    else if ((*tokens_iter)->token_type == TK_RREDIR || (*tokens_iter)->token_type == TK_RAPPEND)
        ret = parse_redir(tokens_iter, node);
    if (ret)
        return (ret);
    if (*tokens_iter && (*tokens_iter)->next != NULL)
    {
        *tokens_iter = (*tokens_iter)->next;
        return (parse(tokens_iter, node, envl));
    }
    return (0);
}

int parse_word(t_token **token_list, t_astnode **node)
{
    if (!(*node))
        return (initializ_new_ast_node(token_list, node));
    else if ((*node) && (*node)->type == TK_PIPE)
        return (set_word_in_pipe(token_list, node));
    else if ((*node) && (*node)->type == TK_RREDIR)
        return (set_word_in_rredir(token_list, node));
    else if ((*node) && (*node)->type == TK_WORD)
        return (set_word_in_word(token_list, node));
    else if ((*node) && (*node)->type == TK_LREDIR)
        return (set_word_in_lredir(token_list, node));
    return (0);
}

int parse_pipe(t_token **token_list, t_astnode **node)
{
    t_astnode *new_node;

    if ((*token_list)->prev && !(*token_list)->next)
        return (4);
    if (!(*token_list)->prev || ((*node) && ((*node)->type == TK_AND || (*node)->type == TK_OR)) || (*token_list)->next->token_type == TK_PIPE)
        return (show_syntax_error((*token_list)->value), 6);
    new_node = (t_astnode *)malloc(sizeof(t_astnode));
    if (new_node == NULL)
        return (1);
    new_node->type = TK_PIPE;
    if (!(*node))
        new_node->left = NULL;
    else
    {
        new_node->left = *node;
        (*node)->parent = new_node;
    }
    new_node->left = *node;
    new_node->parent = NULL;
    *node = new_node;
    new_node->right = NULL;
    return (0);
}

int parse_redir(t_token **token_list, t_astnode **node)
{
    t_astnode *new_node;

    if (!(*token_list)->next || (*token_list)->next->token_type != TK_WORD)
        return (show_syntax_error("newline"), 6);
    new_node = (t_astnode *)malloc(sizeof(t_astnode));
    if (new_node == NULL)
        return (1);
    set_redir_type(new_node, (*token_list)->token_type);
    add_redir_node(node, new_node);
    new_node->left = NULL;
    new_node->right = NULL;
    new_node->data.redirection.filename = ft_strdup((*token_list)->next->value);
    *token_list = (*token_list)->next;
    return (0);
}

int parse_export(char *var_name)
{
    int i;

    i = 0;
    if (ft_isalpha(var_name[i]) || var_name[i] == '_')
    {
        i++;
        while (var_name[i] && (ft_isalnum(var_name[i]) || var_name[i] == '_'))
            i++;
        if (!var_name[i])
            return (0);
    }
    ft_putstr_fd("msh: `", STDERR_FILENO);
    ft_putstr_fd(var_name, STDERR_FILENO);
    ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
    return (EXIT_FAILURE);
    return (1);
}

int	initializ_new_ast_node(t_token **token_list, t_astnode **parent)
{
	t_astnode	*new_node;

	new_node = (t_astnode *)malloc(sizeof(t_astnode));
	if (new_node == NULL)
		return (1);
	new_node->type = TK_WORD;
	new_node->data.command.cmd = ft_strdup((*token_list)->value);
	if (new_node->data.command.cmd == NULL)
		return (1);
	new_node->parent = (*parent);
	new_node->left = NULL;
	new_node->right = NULL;
	*parent = new_node;
	new_node->data.command.thereisin = false;
	new_node->data.command.thereisout = false;
	new_node->data.command.thereispipe = false;
	new_node->data.command.thereisprev = false;
	new_node->data.command.isrightmost = false;
	new_node->data.command.execute = true;
	new_node->data.command.builtin = false;
	new_node->data.command.args = NULL;
	new_node->data.command.pid = -1;
	if (set_word_in_word(token_list, &new_node))
		return (1);
	return (0);
}

int	set_word_in_pipe(t_token **token_list, t_astnode **node)
{
	int			ret;
	t_astnode	*temp;

	if ((*node) && !(*node)->right)
	{
		ret = initializ_new_ast_node(token_list, &(*node)->right);
		if (ret)
			return (1);
		(*node)->right->parent = (*node);
	}
	else if ((*node) && ((*node)->right->type == TK_RREDIR
			|| (*node)->right->type == TK_LREDIR))
	{
		temp = (*node)->right;
		ret = initializ_new_ast_node(token_list, &(*node)->right);
		if (ret)
			return (1);
		(*node)->right->right = temp;
		temp->parent = (*node)->right;
	}
	else if ((*node) && (*node)->right)
		return (set_word_in_word(token_list, &(*node)->right));
	return (0);
}

int	set_word_in_rredir(t_token **token_list, t_astnode **node)
{
	int			ret;
	t_astnode	*new_node;

	new_node = NULL;
	if ((*node) && !(*node)->left)
	{
		ret = initializ_new_ast_node(token_list, &new_node);
		if (ret)
			return (1);
		new_node->parent = (*node)->parent;
		new_node->right = (*node);
		(*node)->parent = new_node;
		*node = new_node;
	}
	else if ((*node) && (*node)->left->type == TK_PIPE)
		return (set_word_in_pipe(token_list, &(*node)->left));
	else if ((*node) && (*node)->left)
		return (set_word_in_word(token_list, &(*node)->left));
	return (0);
}

int	set_word_in_word(t_token **token_list, t_astnode **node)
{
	t_node	*new_t_node;

	new_t_node = node_create((*token_list)->value);
	if (!new_t_node)
		return (1);
	if ((*token_list)->token_type == TK_DOLLAR)
		new_t_node->is_env = true;
	else
		new_t_node->is_env = false;
	list_append(&(*node)->data.command.args, new_t_node);
	return (0);
}

int	set_word_in_lredir(t_token **token_list, t_astnode **node)
{
	t_astnode	*new_node;
	int			ret;

	new_node = NULL;
	ret = initializ_new_ast_node(token_list, &new_node);
	if (ret)
		return (1);
	new_node->parent = NULL;
	new_node->right = (*node);
	new_node->left = NULL;
	(*node)->parent = new_node;
	*node = new_node;
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_word_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: aalshafy <aalshafy@student.42abudhabi.a    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/19 15:26:38 by aalshafy          #+#    #+#             */
/*   Updated: 2024/06/19 16:58:48 by aalshafy         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include "parser.h"
#include <stdio.h>

int initializ_new_ast_node(t_token **token_list, t_astnode **parent)
{
    t_astnode *new_node;

    new_node = (t_astnode *)malloc(sizeof(t_astnode));
    if (new_node == NULL)
        return (1);
    new_node->type = TK_WORD;
    new_node->data.command.cmd = ft_strdup((*token_list)->value);
    if (new_node->data.command.cmd == NULL)
        return (1);
    new_node->parent = (*parent);
    new_node->left = NULL;
    new_node->right = NULL;
    *parent = new_node;
    new_node->data.command.thereisin = false;
    new_node->data.command.thereisout = false;
    new_node->data.command.thereispipe = false;
    new_node->data.command.thereisprev = false;
    new_node->data.command.isrightmost = false;
    new_node->data.command.execute = true;
    new_node->data.command.builtin = false;
    new_node->data.command.args = NULL;
    new_node->data.command.pid = -1;
    if (set_word_in_word(token_list, &new_node))
        return (1);
    return (0);
}

int set_word_in_pipe(t_token **token_list, t_astnode **node)
{
    int ret;
    t_astnode *temp;

    if ((*node) && !(*node)->right)
    {
        ret = initializ_new_ast_node(token_list, &(*node)->right);
        if (ret)
            return (1);
        (*node)->right->parent = (*node);
    }
    else if ((*node) && ((*node)->right->type == TK_RREDIR || (*node)->right->type == TK_LREDIR))
    {
        temp = (*node)->right;
        ret = initializ_new_ast_node(token_list, &(*node)->right);
        if (ret)
            return (1);
        (*node)->right->right = temp;
        temp->parent = (*node)->right;
    }
    else if ((*node) && (*node)->right)
        return (set_word_in_word(token_list, &(*node)->right));
    return (0);
}

int set_word_in_rredir(t_token **token_list, t_astnode **node)
{
    int ret;
    t_astnode *new_node;

    new_node = NULL;
    if ((*node) && !(*node)->left)
    {
        ret = initializ_new_ast_node(token_list, &new_node);
        if (ret)
            return (1);
        new_node->parent = (*node)->parent;
        new_node->right = (*node);
        (*node)->parent = new_node;
        *node = new_node;
    }
    else if ((*node) && (*node)->left->type == TK_PIPE)
        return (set_word_in_pipe(token_list, &(*node)->left));
    else if ((*node) && (*node)->left)
        return (set_word_in_word(token_list, &(*node)->left));
    return (0);
}

int set_word_in_word(t_token **token_list, t_astnode **node)
{
    t_node *new_t_node;

    new_t_node = node_create((*token_list)->value);
    if (!new_t_node)
        return (1);
    if ((*token_list)->token_type == TK_DOLLAR)
        new_t_node->is_env = true;
    else
        new_t_node->is_env = false;
    list_append(&(*node)->data.command.args, new_t_node);
    return (0);
}

int set_word_in_lredir(t_token **token_list, t_astnode **node)
{
    t_astnode *new_node;
    int ret;

    new_node = NULL;
    ret = initializ_new_ast_node(token_list, &new_node);
    if (ret)
        return (1);
    new_node->parent = NULL;
    new_node->right = (*node);
    new_node->left = NULL;
    (*node)->parent = new_node;
    *node = new_node;
    return (0);
}